!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/lugot/documents/university/master/52/operation_research_2/code/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	/p5.9.20210110.0/
$(EXE)	src/Makefile	/^$(EXE): $(OBJS) $(LIBUTILS)$/;"	t
$(LIBUTILS)	src/Makefile	/^$(LIBUTILS) : $(HEADERS_LIBUTILS)$/;"	t
$(LIBUTILS)	src/Makefile	/^$(LIBUTILS): $(OBJS_LIBUTILS)$/;"	t
$(OBJS)	src/Makefile	/^$(OBJS) : $(HEADERS)$/;"	t
$2$-approximation algorithm	thesis/chapters/approximations.tex	/^\\section{$2$-approximation algorithm}$/;"	s
$2$-opt moves	thesis/chapters/heuristics.tex	/^\\subsubsection{$2$-opt moves}$/;"	b	subsection:Refinement heuristics""$k$-opt moves
$3$-opt moves	thesis/chapters/heuristics.tex	/^\\subsubsection{$3$-opt moves}$/;"	b	subsection:Refinement heuristics""$k$-opt moves
$\\nicefrac{3}{2}$-approximation algorithm	thesis/chapters/approximations.tex	/^\\section{$\\nicefrac{3}{2}$-approximation algorithm}$/;"	s
$k$-opt moves	thesis/chapters/heuristics.tex	/^\\subsection{$k$-opt moves}$/;"	u	section:Refinement heuristics
.c.o	src/Makefile	/^.c.o :$/;"	t
.cpp.o	src/Makefile	/^.cpp.o :$/;"	t
AR	src/Makefile	/^AR = ar rc$/;"	m
ATT	include/tsp.h	/^enum weight_types { ATT, EUC_2D, GEO, EXPLICIT, UNHANDLED_WEIGHT_TYPE };$/;"	e	enum:weight_types
Appendix	thesis/main.tex	/^\\chapter{Appendix}$/;"	c
Approximation algorithms	thesis/main.tex	/^\\chapter{Approximation algorithms}$/;"	c
BENDERS	include/tsp.h	/^    BENDERS,$/;"	e	enum:model_types
BENDERS2P_NODELIM	include/globals.h	/^#define BENDERS2P_NODELIM /;"	d
BENDERS2P_PHASE2PERC	include/globals.h	/^#define BENDERS2P_PHASE2PERC /;"	d
BENDERS_CALLBACK	include/tsp.h	/^    BENDERS_CALLBACK,$/;"	e	enum:model_types
BENDERS_TWOPHASES	include/tsp.h	/^    BENDERS_TWOPHASES,$/;"	e	enum:model_types
Benders Method	thesis/main.tex	/^\\chapter{Benders Method}$/;"	c
CALLBACK_VERBOSE	src/globals.c	/^int CALLBACK_VERBOSE = 1;$/;"	v	typeref:typename:int
CAPACITY	src/parsers.c	/^    CAPACITY,$/;"	e	enum:sections	file:
CC	src/Makefile	/^CC = gcc$/;"	m
CCDIR	src/Makefile	/^CCDIR = \/opt\/concorde$/;"	m
CFLAGS	src/Makefile	/^CFLAGS = -Wall -O0 -g$/;"	m
COMMENT	src/parsers.c	/^    COMMENT,$/;"	e	enum:sections	file:
CONCORDELIB	src/Makefile	/^CONCORDELIB = \/opt\/concorde$/;"	m
CPLEX implementations	thesis/chapters/compactmodels.tex	/^\\subsection{CPLEX implementations}$/;"	u	section:Gavish and Graves
CPLEX implementations	thesis/chapters/compactmodels.tex	/^\\subsection{CPLEX implementations}$/;"	u	section:Miller-Tucker-Zemlin
CPLEX_HOME	src/Makefile	/^CPLEX_HOME = \/opt\/ibm\/ILOG\/CPLEX_Studio201\/cplex$/;"	m
Callbacks method	thesis/chapters/benders.tex	/^\\section{Callbacks method}$/;"	s
CmdLineParser	results/perprof.py	/^class CmdLineParser(object):$/;"	c
Compact Models	thesis/main.tex	/^\\chapter{Compact Models}$/;"	c
Compact models comparison	thesis/chapters/compactmodels.tex	/^\\section{Compact models comparison}$/;"	s
Constructive Heuristics	thesis/chapters/heuristics.tex	/^\\section{Constructive Heuristics}$/;"	s
Constructive heuristics comparison	thesis/chapters/heuristics.tex	/^\\subsection{Constructive heuristics comparison}$/;"	u	section:Constructive Heuristics
DEMAND_SECTION	src/parsers.c	/^    DEMAND_SECTION,$/;"	e	enum:sections	file:
DEPOT_SECTION	src/parsers.c	/^    DEPOT_SECTION,$/;"	e	enum:sections	file:
DIMENSION	src/parsers.c	/^    DIMENSION,$/;"	e	enum:sections	file:
DISPLAY_DATA_SECTION	src/parsers.c	/^    DISPLAY_DATA_SECTION,$/;"	e	enum:sections	file:
DISPLAY_DATA_TYPE	src/parsers.c	/^    DISPLAY_DATA_TYPE,$/;"	e	enum:sections	file:
EDGE_DATA_FORMAT	src/parsers.c	/^    EDGE_DATA_FORMAT,$/;"	e	enum:sections	file:
EDGE_DATA_SECTION	src/parsers.c	/^    EDGE_DATA_SECTION,$/;"	e	enum:sections	file:
EDGE_WEIGHT_FORMAT	src/parsers.c	/^    EDGE_WEIGHT_FORMAT,$/;"	e	enum:sections	file:
EDGE_WEIGHT_SECTION	src/parsers.c	/^    EDGE_WEIGHT_SECTION,$/;"	e	enum:sections	file:
EDGE_WEIGHT_TYPE	src/parsers.c	/^    EDGE_WEIGHT_TYPE,$/;"	e	enum:sections	file:
END_OF_FILE	src/parsers.c	/^    END_OF_FILE,$/;"	e	enum:sections	file:
EPSILON	include/globals.h	/^#define EPSILON /;"	d
EUC_2D	include/tsp.h	/^enum weight_types { ATT, EUC_2D, GEO, EXPLICIT, UNHANDLED_WEIGHT_TYPE };$/;"	e	enum:weight_types
EXE	src/Makefile	/^EXE = tsp_approx$/;"	m
EXPLICIT	include/tsp.h	/^enum weight_types { ATT, EUC_2D, GEO, EXPLICIT, UNHANDLED_WEIGHT_TYPE };$/;"	e	enum:weight_types
EXTRA_MILEAGE	include/tsp.h	/^    EXTRA_MILEAGE,$/;"	e	enum:model_types
EXTRA_VERBOSE	src/globals.c	/^int EXTRA_VERBOSE = 0;$/;"	v	typeref:typename:int
Extra Mileage	thesis/chapters/heuristics.tex	/^\\subsection{Extra Mileage}$/;"	u	section:Constructive Heuristics
FIXED_EDGE_SECTION	src/parsers.c	/^    FIXED_EDGE_SECTION,$/;"	e	enum:sections	file:
GENERATE	include/parsers.h	/^enum run_modes { NOT_SPECIFIED, SINGLE_INSTANCE, GENERATE, LOAD_DIR };$/;"	e	enum:run_modes
GENERATED	include/tsp.h	/^enum model_folders { TSPLIB, GENERATED };$/;"	e	enum:model_folders
GENETIC	include/tsp.h	/^    GENETIC$/;"	e	enum:model_types
GENETIC_K	include/globals.h	/^#define GENETIC_K /;"	d
GENETIC_N	include/globals.h	/^#define GENETIC_N /;"	d
GENETIC_NBESTSOLS	include/globals.h	/^#define GENETIC_NBESTSOLS /;"	d
GENETIC_NMOVES	include/globals.h	/^#define GENETIC_NMOVES /;"	d
GENETIC_NMUTATIONS	include/globals.h	/^#define GENETIC_NMUTATIONS /;"	d
GENETIC_PERC_LUCKYCHILDREN	include/globals.h	/^#define GENETIC_PERC_LUCKYCHILDREN /;"	d
GENETIC_PERC_TIME	include/globals.h	/^#define GENETIC_PERC_TIME /;"	d
GEN_NNODES	src/globals.c	/^int GEN_NNODES = 50;$/;"	v	typeref:typename:int
GEO	include/tsp.h	/^enum weight_types { ATT, EUC_2D, GEO, EXPLICIT, UNHANDLED_WEIGHT_TYPE };$/;"	e	enum:weight_types
GGLECT_LAZY	include/tsp.h	/^    GGLECT_LAZY,$/;"	e	enum:model_types
GGLECT_STATIC	include/tsp.h	/^    GGLECT_STATIC,$/;"	e	enum:model_types
GGLIT_LAZY	include/tsp.h	/^    GGLIT_LAZY,$/;"	e	enum:model_types
GGLIT_STATIC	include/tsp.h	/^    GGLIT_STATIC,$/;"	e	enum:model_types
GGLIT_STATIC_DEG2	include/tsp.h	/^    GGLIT_STATIC_DEG2,$/;"	e	enum:model_types
GRASP	include/tsp.h	/^    GRASP,$/;"	e	enum:model_types
GRASP	thesis/chapters/heuristics.tex	/^\\subsection{GRASP}$/;"	u	section:Constructive Heuristics
GRASP_K	include/globals.h	/^#define GRASP_K /;"	d
GREEDY	include/tsp.h	/^    GREEDY,$/;"	e	enum:model_types
Gavish and Graves	thesis/chapters/compactmodels.tex	/^\\section{Gavish and Graves}$/;"	s
Gavish-Graves model, lecture	thesis/chapters/compactmodels.tex	/^\\subsection{Gavish-Graves model, lecture}$/;"	u	section:Gavish and Graves
Gavish-Graves model, literature	thesis/chapters/compactmodels.tex	/^\\subsection{Gavish-Graves model, literature}$/;"	u	section:Gavish and Graves
Genetic algorithm	thesis/chapters/metaheuristics.tex	/^\\section{Genetic algorithm}$/;"	s
Greedy	thesis/chapters/heuristics.tex	/^\\subsection{Greedy}$/;"	u	section:Constructive Heuristics
HARD_FIXING	include/tsp.h	/^    HARD_FIXING,$/;"	e	enum:model_types
HEADERS	src/Makefile	/^HEADERS =$/;"	m
HF_INITIAL_PERC_TIME	include/globals.h	/^#define HF_INITIAL_PERC_TIME /;"	d
HF_ITERATIONS	include/globals.h	/^#define HF_ITERATIONS /;"	d
HF_PERCENTAGE	include/globals.h	/^#define HF_PERCENTAGE /;"	d
Hard Fixing	thesis/chapters/matheuristics.tex	/^\\section{Hard Fixing}$/;"	s
Heuristics	thesis/main.tex	/^\\chapter{Heuristics}$/;"	c
INC	src/Makefile	/^INC = -I..\/include -I${CPLEX_HOME}\/include\/ilcplex -I${CCDIR}$/;"	m
INCLUDE_ADJLIST_H_	include/adjlist.h	/^#define INCLUDE_ADJLIST_H_$/;"	d
INCLUDE_APPROXIMATIONS_H_	include/approximations.h	/^#define INCLUDE_APPROXIMATIONS_H_$/;"	d
INCLUDE_CONSTRUCTIVES_H_	include/constructives.h	/^#define INCLUDE_CONSTRUCTIVES_H_$/;"	d
INCLUDE_GLOBALS_H_	include/globals.h	/^#define INCLUDE_GLOBALS_H_$/;"	d
INCLUDE_METAHEURISTICS_H_	include/metaheuristics.h	/^#define INCLUDE_METAHEURISTICS_H_$/;"	d
INCLUDE_MODELS_BENDERS_H_	include/models/benders.h	/^#define INCLUDE_MODELS_BENDERS_H_$/;"	d
INCLUDE_MODELS_FIXING_H_	include/models/fixing.h	/^#define INCLUDE_MODELS_FIXING_H_$/;"	d
INCLUDE_MODELS_GG_H_	include/models/gg.h	/^#define INCLUDE_MODELS_GG_H_$/;"	d
INCLUDE_MODELS_MTZ_H_	include/models/mtz.h	/^#define INCLUDE_MODELS_MTZ_H_$/;"	d
INCLUDE_MODEL_BUILDER_H_	include/model_builder.h	/^#define INCLUDE_MODEL_BUILDER_H_$/;"	d
INCLUDE_PARSERS_H_	include/parsers.h	/^#define INCLUDE_PARSERS_H_$/;"	d
INCLUDE_PQUEUE_H_	include/pqueue.h	/^#define INCLUDE_PQUEUE_H_$/;"	d
INCLUDE_REFINEMENTS_H_	include/refinements.h	/^#define INCLUDE_REFINEMENTS_H_$/;"	d
INCLUDE_SOLVERS_H_	include/solvers.h	/^#define INCLUDE_SOLVERS_H_$/;"	d
INCLUDE_TRACKER_H_	include/tracker.h	/^#define INCLUDE_TRACKER_H_$/;"	d
INCLUDE_TSP_H_	include/tsp.h	/^#define INCLUDE_TSP_H_$/;"	d
INCLUDE_UNION_FIND_H_	include/union_find.h	/^#define INCLUDE_UNION_FIND_H_$/;"	d
INCLUDE_UTILS_H_	include/utils.h	/^#define INCLUDE_UTILS_H_$/;"	d
INF	include/globals.h	/^#define INF /;"	d
Implementation Details	thesis/chapters/matheuristics.tex	/^\\subsection{Implementation Details}$/;"	u	section:Soft Fixing
Implementation details	thesis/chapters/approximations.tex	/^\\subsection{Implementation details}$/;"	u	section:$2$-approximation algorithm
Implementation details	thesis/chapters/benders.tex	/^\\subsection{Implementation details}$/;"	u	section:The Loop method
Implementation details	thesis/chapters/heuristics.tex	/^\\subsection{Implementation details}$/;"	u	section:Refinement heuristics
Implementation details	thesis/chapters/heuristics.tex	/^\\subsubsection{Implementation details}$/;"	b	subsection:Constructive Heuristics""Extra Mileage
Implementation details	thesis/chapters/heuristics.tex	/^\\subsubsection{Implementation details}$/;"	b	subsection:Constructive Heuristics""GRASP
Implementation details	thesis/chapters/matheuristics.tex	/^\\subsection{Implementation details}$/;"	u	section:Hard Fixing
Implementation details	thesis/chapters/metaheuristics.tex	/^\\subsection{Implementation details}$/;"	u	section:Genetic algorithm
Implementation details	thesis/chapters/metaheuristics.tex	/^\\subsection{Implementation details}$/;"	u	section:Tabu Search
Implementation details	thesis/chapters/metaheuristics.tex	/^\\subsection{Implementation details}$/;"	u	section:Variable Neighborhood Search
Introduction	thesis/main.tex	/^\\chapter{Introduction}$/;"	c
LAZY	src/model_builder.c	/^typedef enum modes_t { STATIC, LAZY } modes;$/;"	e	enum:modes_t	file:
LIBS	src/Makefile	/^LIBS = -L${CPLEX_HOME}\/lib\/x86-64_linux\/static_pic -L. -lcplex -lm -lpthread -ldl ${CONCORDEL/;"	m
LOAD_DIR	include/parsers.h	/^enum run_modes { NOT_SPECIFIED, SINGLE_INSTANCE, GENERATE, LOAD_DIR };$/;"	e	enum:run_modes
MAX_HEAP	include/pqueue.h	/^enum modes { MAX_HEAP, MIN_HEAP };$/;"	e	enum:modes
MIN_HEAP	include/pqueue.h	/^enum modes { MAX_HEAP, MIN_HEAP };$/;"	e	enum:modes
MST	include/tsp.h	/^    MST,$/;"	e	enum:model_types
MTZ_INDICATOR	include/tsp.h	/^    MTZ_INDICATOR,$/;"	e	enum:model_types
MTZ_LAZY	include/tsp.h	/^    MTZ_LAZY,$/;"	e	enum:model_types
MTZ_LAZY_DEG2	include/tsp.h	/^    MTZ_LAZY_DEG2,$/;"	e	enum:model_types
MTZ_LAZY_DEG3	include/tsp.h	/^    MTZ_LAZY_DEG3,$/;"	e	enum:model_types
MTZ_STATIC	include/tsp.h	/^    MTZ_STATIC,$/;"	e	enum:model_types
Mathematical Model	thesis/chapters/introduction.tex	/^\\section{Mathematical Model}$/;"	s
Matheuristics	thesis/main.tex	/^\\chapter{Matheuristics}$/;"	c
Matheuristics comparison	thesis/chapters/matheuristics.tex	/^\\section{Matheuristics comparison}$/;"	s
Metaheuristics	thesis/main.tex	/^\\chapter{Metaheuristics}$/;"	c
Metaheuristics comparison	thesis/chapters/metaheuristics.tex	/^\\section{Metaheuristics comparison}$/;"	s
Miller-Tucker-Zemlin	thesis/chapters/compactmodels.tex	/^\\section{Miller-Tucker-Zemlin}$/;"	s
Miller-Tucker-Zemlin model	thesis/chapters/compactmodels.tex	/^\\subsection{Miller-Tucker-Zemlin model}$/;"	u	section:Miller-Tucker-Zemlin
N	include/adjlist.h	/^    int N;$/;"	m	struct:adjlist_t	typeref:typename:int
N	include/union_find.h	/^    int N;$/;"	m	struct:union_find_t	typeref:typename:int
NAME	src/parsers.c	/^    NAME,$/;"	e	enum:sections	file:
NODE_COORD_SECTION	src/parsers.c	/^    NODE_COORD_SECTION,$/;"	e	enum:sections	file:
NODE_COORD_TYPE	src/parsers.c	/^    NODE_COORD_TYPE,$/;"	e	enum:sections	file:
NOSEC	include/tsp.h	/^    NOSEC,$/;"	e	enum:model_types
NOT_SPECIFIED	include/parsers.h	/^enum run_modes { NOT_SPECIFIED, SINGLE_INSTANCE, GENERATE, LOAD_DIR };$/;"	e	enum:run_modes
Note:	thesis/chapters/compactmodels.tex	/^\\subparagraph{Note:} claim 1 was produced considering adding all the degree$/;"	G	subsection:Miller-Tucker-Zemlin""Speeding up the model
OBJS	src/Makefile	/^OBJS = globals.o main.o tsp.o parsers.o utils.o solvers.o union_find.o model_builder.o models\/m/;"	m
OPTIMAL_TOUR	include/tsp.h	/^    OPTIMAL_TOUR,$/;"	e	enum:model_types
OS	src/Makefile	/^OS := $(shell uname)$/;"	m
On code	thesis/chapters/appendix.tex	/^\\section{On code}$/;"	s
On parameters tuning	thesis/chapters/appendix.tex	/^\\section{On parameters tuning}$/;"	s
On test environment	thesis/chapters/appendix.tex	/^\\section{On test environment}$/;"	s
Problem definition and history	thesis/chapters/introduction.tex	/^\\section{Problem definition and history}$/;"	s
RM	src/Makefile	/^RM = rm -rf$/;"	m
Refinement heuristics	thesis/chapters/heuristics.tex	/^\\section{Refinement heuristics}$/;"	s
SF_INITIAL_K	include/globals.h	/^#define SF_INITIAL_K /;"	d
SF_INITIAL_PERC_TIME	include/globals.h	/^#define SF_INITIAL_PERC_TIME /;"	d
SF_K_STEP	include/globals.h	/^#define SF_K_STEP /;"	d
SF_MAX_K	include/globals.h	/^#define SF_MAX_K /;"	d
SINGLE_INSTANCE	include/parsers.h	/^enum run_modes { NOT_SPECIFIED, SINGLE_INSTANCE, GENERATE, LOAD_DIR };$/;"	e	enum:run_modes
SOFT_FIXING	include/tsp.h	/^    SOFT_FIXING,$/;"	e	enum:model_types
STATIC	src/model_builder.c	/^typedef enum modes_t { STATIC, LAZY } modes;$/;"	e	enum:modes_t	file:
Soft Fixing	thesis/chapters/matheuristics.tex	/^\\section{Soft Fixing}$/;"	s
Speeding up the model	thesis/chapters/compactmodels.tex	/^\\subsection{Speeding up the model}$/;"	u	section:Miller-Tucker-Zemlin
TABU_SEACH_GRASP	include/tsp.h	/^    TABU_SEACH_GRASP,$/;"	e	enum:model_types
TABU_SEACH_RANDOM	include/tsp.h	/^    TABU_SEACH_RANDOM,$/;"	e	enum:model_types
THREEOPT_MULTISTART	include/tsp.h	/^    THREEOPT_MULTISTART,$/;"	e	enum:model_types
TOUR_SECTION	src/parsers.c	/^    TOUR_SECTION,$/;"	e	enum:sections	file:
TSPLIB	include/tsp.h	/^enum model_folders { TSPLIB, GENERATED };$/;"	e	enum:model_folders
TSPextramileage	src/constructives.c	/^solution TSPextramileage(instance inst) {$/;"	f	typeref:typename:solution
TSPgenetic	src/metaheuristics.c	/^solution TSPgenetic(instance inst) {$/;"	f	typeref:typename:solution
TSPgrasp	src/constructives.c	/^solution TSPgrasp(instance inst, int niterations) {$/;"	f	typeref:typename:solution
TSPgreedy	src/constructives.c	/^solution TSPgreedy(instance inst) {$/;"	f	typeref:typename:solution
TSPminspantree	src/approximations.c	/^solution TSPminspantree(instance inst) {$/;"	f	typeref:typename:solution
TSPopt	src/solvers.c	/^solution TSPopt(instance inst, enum model_types model_type) {$/;"	f	typeref:typename:solution
TSPrandom	src/metaheuristics.c	/^solution TSPrandom(instance inst) {$/;"	f	typeref:typename:solution
TSPtabusearch	src/metaheuristics.c	/^solution TSPtabusearch(instance inst, int* succ) {$/;"	f	typeref:typename:solution
TSPthreeopt_multistart	src/refinements.c	/^solution TSPthreeopt_multistart(instance inst) {$/;"	f	typeref:typename:solution
TSPtwoopt_multistart	src/refinements.c	/^solution TSPtwoopt_multistart(instance inst) {$/;"	f	typeref:typename:solution
TSPvns	src/metaheuristics.c	/^solution TSPvns(instance inst, int* succ) {$/;"	f	typeref:typename:solution
TS_MAX_TENURE	include/globals.h	/^#define TS_MAX_TENURE /;"	d
TS_MIN_TENURE	include/globals.h	/^#define TS_MIN_TENURE /;"	d
TS_PHASEDURATION	include/globals.h	/^#define TS_PHASEDURATION /;"	d
TWOOPT_MULTISTART	include/tsp.h	/^    TWOOPT_MULTISTART,$/;"	e	enum:model_types
TWOOPT_NINITIALSOL	include/globals.h	/^#define TWOOPT_NINITIALSOL /;"	d
TYPE	src/parsers.c	/^    TYPE,$/;"	e	enum:sections	file:
Tabu Search	thesis/chapters/metaheuristics.tex	/^\\section{Tabu Search}$/;"	s
The Loop method	thesis/chapters/benders.tex	/^\\section{The Loop method}$/;"	s
The Two-phase Loop method	thesis/chapters/benders.tex	/^\\section{The Two-phase Loop method}$/;"	s
UNHANDLED_SECTION	src/parsers.c	/^    UNHANDLED_SECTION,$/;"	e	enum:sections	file:
UNHANDLED_WEIGHT_TYPE	include/tsp.h	/^enum weight_types { ATT, EUC_2D, GEO, EXPLICIT, UNHANDLED_WEIGHT_TYPE };$/;"	e	enum:weight_types
VERBOSE	src/globals.c	/^int VERBOSE = 0;$/;"	v	typeref:typename:int
VNS_GRASP	include/tsp.h	/^    VNS_GRASP,$/;"	e	enum:model_types
VNS_K_MAX	include/globals.h	/^#define VNS_K_MAX /;"	d
VNS_K_START	include/globals.h	/^#define VNS_K_START /;"	d
VNS_K_STEP	include/globals.h	/^#define VNS_K_STEP /;"	d
VNS_RANDOM	include/tsp.h	/^    VNS_RANDOM,$/;"	e	enum:model_types
Variable Neighborhood Search	thesis/chapters/metaheuristics.tex	/^\\section{Variable Neighborhood Search}$/;"	s
XSMALL	include/globals.h	/^#define XSMALL /;"	d
_GNU_SOURCE	src/refinements.c	/^#define _GNU_SOURCE$/;"	d	file:
__init__	results/perprof.py	/^	def __init__(self):$/;"	m	class:CmdLineParser
addOption	results/perprof.py	/^	def addOption(self, *args, **kwargs):$/;"	m	class:CmdLineParser
add_BENDERS_sec	src/models/benders.c	/^int add_BENDERS_sec(CPXENVptr env, CPXLPptr lp, adjlist l) {$/;"	f	typeref:typename:int
add_BENDERS_sec_callback_candidate	src/models/benders.c	/^int CPXPUBLIC add_BENDERS_sec_callback_candidate(CPXCALLBACKCONTEXTptr context,$/;"	f	typeref:typename:int CPXPUBLIC
add_BENDERS_sec_callback_driver	src/models/benders.c	/^int CPXPUBLIC add_BENDERS_sec_callback_driver(CPXCALLBACKCONTEXTptr context,$/;"	f	typeref:typename:int CPXPUBLIC
add_BENDERS_sec_callback_relaxation	src/models/benders.c	/^int CPXPUBLIC add_BENDERS_sec_callback_relaxation(CPXCALLBACKCONTEXTptr context,$/;"	f	typeref:typename:int CPXPUBLIC
add_GG_variables	src/models/gg.c	/^void add_GG_variables(CPXENVptr env, CPXLPptr lp, instance inst) {$/;"	f	typeref:typename:void
add_GGlect_lazy_sec	src/models/gg.c	/^void add_GGlect_lazy_sec(CPXENVptr env, CPXLPptr lp, instance inst) {$/;"	f	typeref:typename:void
add_GGlect_static_sec	src/models/gg.c	/^void add_GGlect_static_sec(CPXENVptr env, CPXLPptr lp, instance inst) {$/;"	f	typeref:typename:void
add_GGlit_lazy_sec	src/models/gg.c	/^void add_GGlit_lazy_sec(CPXENVptr env, CPXLPptr lp, instance inst) {$/;"	f	typeref:typename:void
add_GGlit_static_sec	src/models/gg.c	/^void add_GGlit_static_sec(CPXENVptr env, CPXLPptr lp, instance inst) {$/;"	f	typeref:typename:void
add_MTZ_indicator_sec	src/models/mtz.c	/^void add_MTZ_indicator_sec(CPXENVptr env, CPXLPptr lp, instance inst) {$/;"	f	typeref:typename:void
add_MTZ_lazy_sec	src/models/mtz.c	/^void add_MTZ_lazy_sec(CPXENVptr env, CPXLPptr lp, instance inst) {$/;"	f	typeref:typename:void
add_MTZ_static_sec	src/models/mtz.c	/^void add_MTZ_static_sec(CPXENVptr env, CPXLPptr lp, instance inst) {$/;"	f	typeref:typename:void
add_MTZ_variables	src/models/mtz.c	/^void add_MTZ_variables(CPXENVptr env, CPXLPptr lp, instance inst) {$/;"	f	typeref:typename:void
add_asymm_constraints	src/model_builder.c	/^void add_asymm_constraints(CPXENVptr env, CPXLPptr lp, instance inst) {$/;"	f	typeref:typename:void
add_asymm_variables	src/model_builder.c	/^void add_asymm_variables(CPXENVptr env, CPXLPptr lp, instance inst) {$/;"	f	typeref:typename:void
add_deg2_sec	src/model_builder.c	/^void add_deg2_sec(CPXENVptr env, CPXLPptr lp, instance inst, modes mode) {$/;"	f	typeref:typename:void
add_deg3_sec	src/model_builder.c	/^void add_deg3_sec(CPXENVptr env, CPXLPptr lp, instance inst, modes mode) {$/;"	f	typeref:typename:void
add_params	src/tsp.c	/^void add_params(instance inst, cplex_params params) {$/;"	f	typeref:typename:void
add_solution	src/tsp.c	/^void add_solution(instance inst, solution sol) {$/;"	f	typeref:typename:void
add_symm_constraints	src/model_builder.c	/^void add_symm_constraints(CPXENVptr env, CPXLPptr lp, instance inst) {$/;"	f	typeref:typename:void
add_symm_variables	src/model_builder.c	/^void add_symm_variables(CPXENVptr env, CPXLPptr lp, instance inst) {$/;"	f	typeref:typename:void
adjlist	include/adjlist.h	/^} * adjlist;$/;"	t	typeref:struct:adjlist_t *
adjlist_add_edge	src/adjlist.c	/^void adjlist_add_edge(adjlist l, int i, int j) {$/;"	f	typeref:typename:void
adjlist_create	src/adjlist.c	/^adjlist adjlist_create(int N) {$/;"	f	typeref:typename:adjlist
adjlist_free	src/adjlist.c	/^void adjlist_free(adjlist l) {$/;"	f	typeref:typename:void
adjlist_get_edge	src/adjlist.c	/^int adjlist_get_edge(adjlist l, int* u, int* v) {$/;"	f	typeref:typename:int
adjlist_get_loose_ends	src/adjlist.c	/^int adjlist_get_loose_ends(adjlist l, int* end1, int* end2) {$/;"	f	typeref:typename:int
adjlist_get_subtour	src/adjlist.c	/^int* adjlist_get_subtour(adjlist l, int* subsize) {$/;"	f	typeref:typename:int *
adjlist_hard_reset	src/adjlist.c	/^void adjlist_hard_reset(adjlist l) {$/;"	f	typeref:typename:void
adjlist_print	src/adjlist.c	/^void adjlist_print(adjlist l) {$/;"	f	typeref:typename:void
adjlist_reset	src/adjlist.c	/^void adjlist_reset(adjlist l) {$/;"	f	typeref:typename:void
adjlist_single_tour	src/adjlist.c	/^int adjlist_single_tour(adjlist l) {$/;"	f	typeref:typename:int
adjlist_t	include/adjlist.h	/^typedef struct adjlist_t {$/;"	s
again	src/Makefile	/^again:$/;"	t
all	src/Makefile	/^all: $(EXE)$/;"	t
appendix:testenv	thesis/chapters/appendix.tex	/^\\label{appendix:testenv}$/;"	l
appendix:tuning	thesis/chapters/appendix.tex	/^\\label{appendix:tuning}$/;"	l
available_memory	include/tsp.h	/^    int available_memory;$/;"	m	struct:cplex_params_t	typeref:typename:int
balas1980pivot	thesis/bib/references.bib	/^@article{balas1980pivot,$/;"	a
battery_test	include/parsers.h	/^    int battery_test;$/;"	m	struct:run_options_t	typeref:typename:int
bit	include/adjlist.h	/^    int bit;$/;"	m	struct:adjlist_t	typeref:typename:int
breakout	thesis/bib/ludography.bib	/^@misc{breakout,$/;"	n
build_time	include/tsp.h	/^    double build_time;$/;"	m	struct:solution_t	typeref:typename:double
build_tsp_model	src/model_builder.c	/^double build_tsp_model(CPXENVptr env, CPXLPptr lp, instance inst,$/;"	f	typeref:typename:double
capacity	include/pqueue.h	/^    int capacity;$/;"	m	struct:pqueue_t	typeref:typename:int
capacity	include/tracker.h	/^    int capacity;$/;"	m	struct:tracker_t	typeref:typename:int
capacity	include/union_find.h	/^    int capacity;$/;"	m	struct:tree_node_t	typeref:typename:int
ccw	src/utils.c	/^int ccw(node a, node b, node c) {$/;"	f	typeref:typename:int
chap:Heuristics	thesis/main.tex	/^\\label{chap:Heuristics}$/;"	l
chap:Matheuristics	thesis/main.tex	/^\\label{chap:Matheuristics}$/;"	l
chap:metaheuristics	thesis/main.tex	/^\\label{chap:metaheuristics}$/;"	l
child	src/metaheuristics.c	/^solution child(instance inst, solution parent1, solution parent2) {$/;"	f	typeref:typename:solution
clean	src/Makefile	/^clean:$/;"	t
colors	results/perprof.py	/^colors = ['r', 'b', 'y', 'g', 'm', 'c']$/;"	v
compute_zstar	src/utils.c	/^double compute_zstar(instance inst, solution sol) {$/;"	f	typeref:typename:double
context	src/models/benders.c	/^    CPXCALLBACKCONTEXTptr context;$/;"	m	struct:doit_fn_input_t	typeref:typename:CPXCALLBACKCONTEXTptr	file:
cplex_params	include/tsp.h	/^} * cplex_params;$/;"	t	typeref:struct:cplex_params_t *
cplex_params_t	include/tsp.h	/^typedef struct cplex_params_t {$/;"	s
create_empty_instance	src/tsp.c	/^instance create_empty_instance() {$/;"	f	typeref:typename:instance
create_instance	src/tsp.c	/^instance create_instance(cplex_params params) {$/;"	f	typeref:typename:instance
create_node	src/pqueue.c	/^pqueue_node create_node(double key, int val) {$/;"	f	typeref:typename:pqueue_node
create_options	src/parsers.c	/^run_options create_options() {$/;"	f	typeref:typename:run_options
create_params	src/tsp.c	/^cplex_params create_params() {$/;"	f	typeref:typename:cplex_params
create_solution	src/tsp.c	/^solution create_solution(instance inst, enum model_types model_type,$/;"	f	typeref:typename:solution
cross	src/utils.c	/^double cross(node a, node b) { return a.x * b.y - a.y * b.x; }$/;"	f	typeref:typename:double
czyzyk1998neos	thesis/bib/references.bib	/^@article{czyzyk1998neos,$/;"	a
dantzig1954solution	thesis/bib/references.bib	/^@article{dantzig1954solution,$/;"	a
dashes	results/perprof.py	/^dashes = ['-',  # solid line$/;"	v
data	include/pqueue.h	/^    struct pqueue_node_t** data;$/;"	m	struct:pqueue_t	typeref:struct:pqueue_node_t **
defLW	results/perprof.py	/^defLW = 1.2  # default line width$/;"	v
defMS	results/perprof.py	/^defMS = 7  # default marker size$/;"	v
dist	src/utils.c	/^double dist(int i, int j, instance inst) {$/;"	f	typeref:typename:double
distance_time	include/tsp.h	/^    double distance_time;$/;"	m	struct:solution_t	typeref:typename:double
doit_fn_concorde	src/models/benders.c	/^int doit_fn_concorde(double cutval, int cutcount, int* cut, void* in) {$/;"	f	typeref:typename:int
doit_fn_input	src/models/benders.c	/^} * doit_fn_input;$/;"	t	typeref:struct:doit_fn_input_t *	file:
doit_fn_input_t	src/models/benders.c	/^typedef struct doit_fn_input_t {$/;"	s	file:
dolan2001neos	thesis/bib/references.bib	/^@article{dolan2001neos,$/;"	a
dolan2002benchmarking	thesis/bib/references.bib	/^@article{dolan2002benchmarking,$/;"	a
edge	include/tsp.h	/^} edge;$/;"	t	typeref:struct:edge_t
edge_t	include/tsp.h	/^typedef struct edge_t {$/;"	s
edges	include/tsp.h	/^    edge* edges;$/;"	m	struct:solution_t	typeref:typename:edge *
edges_tosucc	src/utils.c	/^int* edges_tosucc(edge* edges, int nnodes) {$/;"	f	typeref:typename:int *
end	include/tsp.h	/^    double end;$/;"	m	struct:solution_t	typeref:typename:double
fig:GG_example	thesis/chapters/compactmodels.tex	/^    \\label{fig:GG_example}$/;"	l
fig:MTZ_example	thesis/chapters/compactmodels.tex	/^    \\label{fig:MTZ_example}$/;"	l
fig:flow around cylinder	thesis/chapters/introduction.tex	/^    \\label{fig:flow around cylinder} $/;"	l
fig:sub1	thesis/chapters/approximations.tex	/^        \\label{fig:sub1}$/;"	l
fig:sub1	thesis/chapters/benders.tex	/^        \\label{fig:sub1}$/;"	l
fig:sub1	thesis/chapters/heuristics.tex	/^        \\label{fig:sub1}$/;"	l
fig:sub2	thesis/chapters/approximations.tex	/^        \\label{fig:sub2}$/;"	l
fig:sub2	thesis/chapters/benders.tex	/^        \\label{fig:sub2}$/;"	l
fig:sub2	thesis/chapters/heuristics.tex	/^        \\label{fig:sub2}$/;"	l
fischetti2003local	thesis/bib/references.bib	/^@article{fischetti2003local,$/;"	a
free_instance	src/tsp.c	/^void free_instance(instance inst) {$/;"	f	typeref:typename:void
free_options	src/parsers.c	/^void free_options(run_options options) {$/;"	f	typeref:typename:void
free_params	src/tsp.c	/^void free_params(cplex_params params) { free(params); }$/;"	f	typeref:typename:void
free_solution	src/tsp.c	/^void free_solution(solution sol) {$/;"	f	typeref:typename:void
gavish1978travelling	thesis/bib/references.bib	/^@article{gavish1978travelling,$/;"	a
generate_random_instance	src/tsp.c	/^instance generate_random_instance(int id, int nnodes) {$/;"	f	typeref:typename:instance
generate_random_instances	src/tsp.c	/^instance* generate_random_instances(int ninstances, int nnodes) {$/;"	f	typeref:typename:instance *
geodist	src/utils.c	/^double geodist(size_t i, size_t j, instance inst) {$/;"	f	typeref:typename:double
get_asymmsol	src/solvers.c	/^void get_asymmsol(double* xstar, solution sol) {$/;"	f	typeref:typename:void
get_symmsol	src/solvers.c	/^void get_symmsol(double* xstar, solution sol) {$/;"	f	typeref:typename:void
glover1986future	thesis/bib/references.bib	/^@article{glover1986future,$/;"	a
gropp1997optimization	thesis/bib/references.bib	/^@techreport{gropp1997optimization,$/;"	t
hook	src/globals.c	/^int hook = 0;$/;"	v	typeref:typename:int
i	include/adjlist.h	/^    int i;$/;"	m	struct:adjlist_t	typeref:typename:int
i	include/tsp.h	/^    int i, j;$/;"	m	struct:edge_t	typeref:typename:int
i	include/tsp.h	/^    int i, j;$/;"	m	struct:wedge_t	typeref:typename:int
inst	include/tsp.h	/^    struct instance_t* inst;$/;"	m	struct:solution_t	typeref:struct:instance_t *
instance	include/tsp.h	/^} * instance;$/;"	t	typeref:struct:instance_t *
instance_comment	include/tsp.h	/^    char* instance_comment;$/;"	m	struct:instance_t	typeref:typename:char *
instance_folder	include/parsers.h	/^    char* instance_folder;$/;"	m	struct:run_options_t	typeref:typename:char *
instance_folder	include/tsp.h	/^    char* instance_folder;$/;"	m	struct:instance_t	typeref:typename:char *
instance_name	include/parsers.h	/^    char* instance_name;$/;"	m	struct:run_options_t	typeref:typename:char *
instance_name	include/tsp.h	/^    char* instance_name;$/;"	m	struct:instance_t	typeref:typename:char *
instance_t	include/tsp.h	/^typedef struct instance_t {$/;"	s
intset	src/utils.c	/^void* intset(int* arr, int c, int n) {$/;"	f	typeref:typename:void *
j	include/tsp.h	/^    int i, j;$/;"	m	struct:edge_t	typeref:typename:int
j	include/tsp.h	/^    int i, j;$/;"	m	struct:wedge_t	typeref:typename:int
k	include/pqueue.h	/^    int k;$/;"	m	struct:topkqueue_t	typeref:typename:int
key	include/pqueue.h	/^    double key;$/;"	m	struct:pqueue_node_t	typeref:typename:double
kick	src/refinements.c	/^void kick(int* succ, int nnodes, int strength) {$/;"	f	typeref:typename:void
l2dist	src/utils.c	/^double l2dist(size_t i, size_t j, instance inst) {$/;"	f	typeref:typename:double
left	src/pqueue.c	/^int left(int i) { return 2 * i + 1; }$/;"	f	typeref:typename:int
list_files	src/utils.c	/^char** list_files(char* instance_folder, int* nmodels) {$/;"	f	typeref:typename:char **
load_optimal	include/parsers.h	/^    int load_optimal;$/;"	m	struct:run_options_t	typeref:typename:int
main	results/perprof.py	/^def main():$/;"	f
main	src/main.c	/^int main(int argc, char** argv) {$/;"	f	typeref:typename:int
markers	results/perprof.py	/^markers = ['+', 'x', 's', '^', 'o', 'd']$/;"	v
max	src/utils.c	/^double max(double a, double b) { return a > b ? a : b; }$/;"	f	typeref:typename:double
maxi	src/utils.c	/^int maxi(int a, int b) { return a > b ? a : b; }$/;"	f	typeref:typename:int
miller1960integer	thesis/bib/references.bib	/^@article{miller1960integer,$/;"	a
min	src/utils.c	/^double min(double a, double b) { return a < b ? a : b; }$/;"	f	typeref:typename:double
mini	src/utils.c	/^int mini(int a, int b) { return a < b ? a : b; }$/;"	f	typeref:typename:int
mladenovic1997variable	thesis/bib/references.bib	/^@article{mladenovic1997variable,$/;"	a
mode	include/parsers.h	/^    enum run_modes mode;$/;"	m	struct:run_options_t	typeref:enum:run_modes
mode	include/pqueue.h	/^    enum modes mode;$/;"	m	struct:pqueue_t	typeref:enum:modes
model_folder_tostring	src/utils.c	/^char* model_folder_tostring(enum model_folders folder) {$/;"	f	typeref:typename:char *
model_folders	include/tsp.h	/^enum model_folders { TSPLIB, GENERATED };$/;"	g
model_type	include/tsp.h	/^    enum model_types model_type;$/;"	m	struct:solution_t	typeref:enum:model_types
model_type_tostring	src/utils.c	/^char* model_type_tostring(enum model_types model_type) {$/;"	f	typeref:typename:char *
model_types	include/tsp.h	/^enum model_types {$/;"	g
modes	include/pqueue.h	/^enum modes { MAX_HEAP, MIN_HEAP };$/;"	g
modes	src/model_builder.c	/^typedef enum modes_t { STATIC, LAZY } modes;$/;"	t	typeref:enum:modes_t	file:
modes_t	src/model_builder.c	/^typedef enum modes_t { STATIC, LAZY } modes;$/;"	g	file:
ncols	include/tsp.h	/^    int ncols;$/;"	m	struct:instance_t	typeref:typename:int
nedges	include/tsp.h	/^    int nedges;$/;"	m	struct:solution_t	typeref:typename:int
nedges	src/models/benders.c	/^    int nedges;$/;"	m	struct:doit_fn_input_t	typeref:typename:int	file:
neigh	include/adjlist.h	/^    int (*neigh)[2];$/;"	m	struct:adjlist_t	typeref:typename:int (*)[2]
nnodes	include/tsp.h	/^    int nnodes;$/;"	m	struct:instance_t	typeref:typename:int
node	include/tsp.h	/^} node;$/;"	t	typeref:struct:node_t
node_t	include/tsp.h	/^typedef struct node_t {$/;"	s
nodelexcmp	src/utils.c	/^int nodelexcmp(const void* a, const void* b) {$/;"	f	typeref:typename:int
nodes	include/tsp.h	/^    node* nodes;$/;"	m	struct:instance_t	typeref:typename:node *
np	results/perprof.py	/^import numpy as np$/;"	I	nameref:module:numpy
nsets	include/union_find.h	/^    int nsets;$/;"	m	struct:union_find_t	typeref:typename:int
nsols	include/tsp.h	/^    int nsols;$/;"	m	struct:instance_t	typeref:typename:int
num_threads	include/tsp.h	/^    int num_threads;$/;"	m	struct:cplex_params_t	typeref:typename:int
objs	include/tracker.h	/^    double* objs;$/;"	m	struct:tracker_t	typeref:typename:double *
orman2006survey	thesis/bib/references.bib	/^@article{orman2006survey,$/;"	a
p	include/union_find.h	/^    int *p, *rank, *size_of_set;$/;"	m	struct:union_find_t	typeref:typename:int *
pair	include/utils.h	/^} pair;$/;"	t	typeref:struct:pair_t
pair_t	include/utils.h	/^typedef struct pair_t {$/;"	s
paircmp	src/utils.c	/^int paircmp(const void* a, const void* b) {$/;"	f	typeref:typename:int
params	include/tsp.h	/^    cplex_params params;$/;"	m	struct:instance_t	typeref:typename:cplex_params
parent	src/pqueue.c	/^int parent(int i) { return (i - 1) \/ 2; }$/;"	f	typeref:typename:int
parseArgs	results/perprof.py	/^	def parseArgs(self):$/;"	m	class:CmdLineParser
parse_command_line	src/parsers.c	/^void parse_command_line(int argc, char** argv, cplex_params params,$/;"	f	typeref:typename:void
parse_input_dir	src/parsers.c	/^instance* parse_input_dir(char* instance_folder, char* file_extension,$/;"	f	typeref:typename:instance *
parse_input_dir_bounded	src/parsers.c	/^instance* parse_input_dir_bounded(char* instance_folder, char* file_extension,$/;"	f	typeref:typename:instance *
parse_input_file	src/parsers.c	/^instance parse_input_file(char* instance_name, char* file_extension,$/;"	f	typeref:typename:instance
pathcmp	src/utils.c	/^int pathcmp(const void* a, const void* b, void* data) {$/;"	f	typeref:typename:int
perform_BENDERS	src/models/benders.c	/^void perform_BENDERS(CPXENVptr env, CPXLPptr lp, instance inst, double* xstar,$/;"	f	typeref:typename:void
perform_HARD_FIXING	src/models/fixing.c	/^void perform_HARD_FIXING(CPXENVptr env, CPXLPptr lp, instance inst,$/;"	f	typeref:typename:void
perform_SOFT_FIXING	src/models/fixing.c	/^void perform_SOFT_FIXING(CPXENVptr env, CPXLPptr lp, instance inst,$/;"	f	typeref:typename:void
plot_graphviz	src/tsp.c	/^void plot_graphviz(solution sol, int* edgecolors, int version) {$/;"	f	typeref:typename:void
plot_profiler	src/tsp.c	/^void plot_profiler(instance* insts, int ninstances, int plot_obj) {$/;"	f	typeref:typename:void
plot_tracking	src/tsp.c	/^void plot_tracking(instance* insts, int ninstances, int dist) {$/;"	f	typeref:typename:void
plt	results/perprof.py	/^import matplotlib.pyplot as plt$/;"	I	nameref:module:matplotlib.pyplot
pq	include/pqueue.h	/^    pqueue pq;$/;"	m	struct:topkqueue_t	typeref:typename:pqueue
pqueue	include/pqueue.h	/^} * pqueue;$/;"	t	typeref:struct:pqueue_t *
pqueue_create	src/pqueue.c	/^pqueue pqueue_create(enum modes mode) {$/;"	f	typeref:typename:pqueue
pqueue_empty	src/pqueue.c	/^int pqueue_empty(pqueue pq) { return pq->size == 0; }$/;"	f	typeref:typename:int
pqueue_free	src/pqueue.c	/^void pqueue_free(pqueue pq) {$/;"	f	typeref:typename:void
pqueue_node	include/pqueue.h	/^} * pqueue_node;$/;"	t	typeref:struct:pqueue_node_t *
pqueue_node_t	include/pqueue.h	/^typedef struct pqueue_node_t {$/;"	s
pqueue_pop	src/pqueue.c	/^int pqueue_pop(pqueue pq) {$/;"	f	typeref:typename:int
pqueue_print	src/pqueue.c	/^void pqueue_print(pqueue pq) {$/;"	f	typeref:typename:void
pqueue_push	src/pqueue.c	/^void pqueue_push(pqueue pq, double key, int val) {$/;"	f	typeref:typename:void
pqueue_t	include/pqueue.h	/^typedef struct pqueue_t {$/;"	s
pqueue_top	src/pqueue.c	/^int pqueue_top(pqueue pq) { return pq->data[0]->val; }$/;"	f	typeref:typename:int
pqueue_top_key	src/pqueue.c	/^double pqueue_top_key(pqueue pq) { return pq->data[0]->key; }$/;"	f	typeref:typename:double
print_cplex_params	src/tsp.c	/^void print_cplex_params(cplex_params params) {$/;"	f	typeref:typename:void
print_error	src/utils.c	/^void print_error(const char* err, ...) {$/;"	f	typeref:typename:void
print_instance	src/tsp.c	/^void print_instance(instance inst, int print_data) {$/;"	f	typeref:typename:void
print_solution	src/tsp.c	/^void print_solution(solution sol, int print_data) {$/;"	f	typeref:typename:void
print_usage	src/parsers.c	/^void print_usage() {$/;"	f	typeref:typename:void
randomseed	include/tsp.h	/^    int randomseed;$/;"	m	struct:cplex_params_t	typeref:typename:int
randomtour	src/utils.c	/^int* randomtour(int nnodes, unsigned int seedp) {$/;"	f	typeref:typename:int *
rank	include/union_find.h	/^    int *p, *rank, *size_of_set;$/;"	m	struct:union_find_t	typeref:typename:int *
reachable	src/utils.c	/^int reachable(int* succ, int i, int j) {$/;"	f	typeref:typename:int
readTable	results/perprof.py	/^def readTable(fp, delimiter):$/;"	f
rev	results/utils.py	/^def rev(nnodes, fun, target):$/;"	f
reverse_path	src/utils.c	/^void reverse_path(int* succ, int nnodes, int start, int end) {$/;"	f	typeref:typename:void
right	src/pqueue.c	/^int right(int i) { return 2 * i + 2; }$/;"	f	typeref:typename:int
run_modes	include/parsers.h	/^enum run_modes { NOT_SPECIFIED, SINGLE_INSTANCE, GENERATE, LOAD_DIR };$/;"	g
run_options	include/parsers.h	/^} * run_options;$/;"	t	typeref:struct:run_options_t *
run_options_t	include/parsers.h	/^typedef struct run_options_t {$/;"	s
save_instance	src/tsp.c	/^void save_instance(instance inst) {$/;"	f	typeref:typename:void
sawik2016note	thesis/bib/references.bib	/^@article{sawik2016note,$/;"	a
section_enumerator	src/parsers.c	/^enum sections section_enumerator(char* section_name) {$/;"	f	typeref:enum:sections
sections	src/parsers.c	/^enum sections {$/;"	g	file:
setting	src/Makefile	/^setting = -1$/;"	m
setting	src/Makefile	/^setting = 1$/;"	m
shiftdown	src/pqueue.c	/^void shiftdown(pqueue pq, int i) {$/;"	f	typeref:typename:void
shiftup	src/pqueue.c	/^void shiftup(pqueue pq, int i) {$/;"	f	typeref:typename:void
si	include/union_find.h	/^    int si; \/* stack index *\/$/;"	m	struct:union_find_t	typeref:typename:int
size	include/pqueue.h	/^    int size;$/;"	m	struct:pqueue_t	typeref:typename:int
size	include/tracker.h	/^    int size;$/;"	m	struct:tracker_t	typeref:typename:int
size	include/union_find.h	/^    int size;$/;"	m	struct:tree_node_t	typeref:typename:int
size_of_set	include/union_find.h	/^    int *p, *rank, *size_of_set;$/;"	m	struct:union_find_t	typeref:typename:int *
sols	include/tsp.h	/^    struct solution_t** sols;$/;"	m	struct:instance_t	typeref:struct:solution_t **
solution	include/tsp.h	/^} * solution;$/;"	t	typeref:struct:solution_t *
solution_t	include/tsp.h	/^typedef struct solution_t {$/;"	s
solve	src/solvers.c	/^solution solve(instance inst, enum model_types model_type) {$/;"	f	typeref:typename:solution
solve_time	include/tsp.h	/^    double solve_time;$/;"	m	struct:solution_t	typeref:typename:double
sons	include/union_find.h	/^    int* sons;$/;"	m	struct:tree_node_t	typeref:typename:int *
spaceinvaders	thesis/bib/ludography.bib	/^@misc{spaceinvaders,$/;"	n
stack	include/union_find.h	/^    int* stack;$/;"	m	struct:union_find_t	typeref:typename:int *
start	include/tsp.h	/^    double start;$/;"	m	struct:solution_t	typeref:typename:double
stopwatch	src/utils.c	/^int64_t stopwatch(struct timespec* s, struct timespec* e) {$/;"	f	typeref:typename:int64_t
stopwatch_n	src/utils.c	/^int64_t stopwatch_n(struct timespec* s, struct timespec* e) {$/;"	f	typeref:typename:int64_t
stringcmp	src/utils.c	/^int stringcmp(const void* p1, const void* p2) {$/;"	f	typeref:typename:int
swap	src/utils.c	/^void swap(int* x, int* y) {$/;"	f	typeref:typename:void
swap_node	src/pqueue.c	/^void swap_node(pqueue_node* n, pqueue_node* m) {$/;"	f	typeref:typename:void
t	include/tsp.h	/^    tracker t;$/;"	m	struct:solution_t	typeref:typename:tracker
tests	include/parsers.h	/^    int tests;$/;"	m	struct:run_options_t	typeref:typename:int
threeopt_move	src/refinements.c	/^void threeopt_move(int* succ, int nnodes, int a, int b, int c, instance inst) {$/;"	f	typeref:typename:void
threeopt_pick	src/refinements.c	/^double threeopt_pick(instance inst, int* succ, int* a, int* b, int* c,$/;"	f	typeref:typename:double
threeopt_refinement	src/refinements.c	/^double threeopt_refinement(instance inst, int* succ, int nnodes,$/;"	f	typeref:typename:double
timelimit	include/tsp.h	/^    double timelimit;$/;"	m	struct:cplex_params_t	typeref:typename:double
times	include/tracker.h	/^    double* times;$/;"	m	struct:tracker_t	typeref:typename:double *
tn_add_son	src/union_find.c	/^void tn_add_son(tree_node tn, int s) {$/;"	f	typeref:typename:void
tn_create	src/union_find.c	/^tree_node tn_create() {$/;"	f	typeref:typename:tree_node
tn_free	src/union_find.c	/^void tn_free(tree_node tn) {$/;"	f	typeref:typename:void
tns	include/union_find.h	/^    tree_node* tns;$/;"	m	struct:union_find_t	typeref:typename:tree_node *
topkqueue	include/pqueue.h	/^} * topkqueue;$/;"	t	typeref:struct:topkqueue_t *
topkqueue_create	src/pqueue.c	/^topkqueue topkqueue_create(int k) {$/;"	f	typeref:typename:topkqueue
topkqueue_free	src/pqueue.c	/^void topkqueue_free(topkqueue tk) {$/;"	f	typeref:typename:void
topkqueue_print	src/pqueue.c	/^void topkqueue_print(topkqueue tk) { pqueue_print(tk->pq); }$/;"	f	typeref:typename:void
topkqueue_push	src/pqueue.c	/^void topkqueue_push(topkqueue tk, double key, int val) {$/;"	f	typeref:typename:void
topkqueue_randompick	src/pqueue.c	/^int topkqueue_randompick(topkqueue tk) {$/;"	f	typeref:typename:int
topkqueue_t	include/pqueue.h	/^typedef struct topkqueue_t {$/;"	s
tracker	include/tracker.h	/^} * tracker;$/;"	t	typeref:struct:tracker_t *
tracker_add	src/tracker.c	/^void tracker_add(tracker t, double time, double obj) {$/;"	f	typeref:typename:void
tracker_create	src/tracker.c	/^tracker tracker_create() {$/;"	f	typeref:typename:tracker
tracker_find	src/tracker.c	/^double tracker_find(tracker t, double obj) {$/;"	f	typeref:typename:double
tracker_free	src/tracker.c	/^void tracker_free(tracker t) {$/;"	f	typeref:typename:void
tracker_print	src/tracker.c	/^void tracker_print(tracker t) {$/;"	f	typeref:typename:void
tracker_t	include/tracker.h	/^typedef struct tracker_t {$/;"	s
tree_node	include/union_find.h	/^} * tree_node;$/;"	t	typeref:struct:tree_node_t *
tree_node_t	include/union_find.h	/^typedef struct tree_node_t {$/;"	s
twoopt_delta	src/refinements.c	/^double twoopt_delta(instance inst, int* succ, int i, int j) {$/;"	f	typeref:typename:double
twoopt_move	src/refinements.c	/^void twoopt_move(int* succ, int nnodes, int a, int b) {$/;"	f	typeref:typename:void
twoopt_pick	src/refinements.c	/^double twoopt_pick(instance inst, int* succ, int* a, int* b) {$/;"	f	typeref:typename:double
twoopt_refinement	src/refinements.c	/^double twoopt_refinement(instance inst, int* succ, int nnodes,$/;"	f	typeref:typename:double
twoopt_refinement_notimelim	src/refinements.c	/^double twoopt_refinement_notimelim(instance inst, int* succ, int nnodes) {$/;"	f	typeref:typename:double
twoopt_tabu_pick	src/refinements.c	/^double twoopt_tabu_pick(instance inst, int* succ, int* tabu_nodes, int tenure,$/;"	f	typeref:typename:double
uf_create	src/union_find.c	/^union_find uf_create(int N) {$/;"	f	typeref:typename:union_find
uf_find_set	src/union_find.c	/^int uf_find_set(union_find uf, int i) {$/;"	f	typeref:typename:int
uf_free	src/union_find.c	/^void uf_free(union_find uf) {$/;"	f	typeref:typename:void
uf_postorder	src/union_find.c	/^int uf_postorder(union_find uf, int* next) {$/;"	f	typeref:typename:int
uf_same_set	src/union_find.c	/^int uf_same_set(union_find uf, int i, int j) {$/;"	f	typeref:typename:int
uf_set_size	src/union_find.c	/^int uf_set_size(union_find uf, int i) {$/;"	f	typeref:typename:int
uf_union_set	src/union_find.c	/^void uf_union_set(union_find uf, int i, int j) {$/;"	f	typeref:typename:void
union_find	include/union_find.h	/^} * union_find;$/;"	t	typeref:struct:union_find_t *
union_find_t	include/union_find.h	/^typedef struct union_find_t {$/;"	s
upos	results/utils.py	/^def upos(i, nnodes):$/;"	f
upos	src/utils.c	/^int upos(int i, int nnodes) { return (nnodes * nnodes) + i - 1; }$/;"	f	typeref:typename:int
val	include/pqueue.h	/^    int val;$/;"	m	struct:pqueue_node_t	typeref:typename:int
visitable	src/utils.c	/^int visitable(int* link, int nnodes) {$/;"	f	typeref:typename:int
visited	include/adjlist.h	/^    int* visited;$/;"	m	struct:adjlist_t	typeref:typename:int *
visited	include/union_find.h	/^    int* visited;$/;"	m	struct:union_find_t	typeref:typename:int *
w	include/tsp.h	/^    double w;$/;"	m	struct:wedge_t	typeref:typename:double
w	include/utils.h	/^    double w;$/;"	m	struct:pair_t	typeref:typename:double
wedge	include/tsp.h	/^} wedge;$/;"	t	typeref:struct:wedge_t
wedge_t	include/tsp.h	/^typedef struct wedge_t {$/;"	s
wedgecmp	src/utils.c	/^int wedgecmp(const void* a, const void* b) {$/;"	f	typeref:typename:int
weight_type	include/tsp.h	/^    enum weight_types weight_type;$/;"	m	struct:instance_t	typeref:enum:weight_types
weight_type_enumerator	src/parsers.c	/^enum weight_types weight_type_enumerator(char* section_param) {$/;"	f	typeref:enum:weight_types
weight_types	include/tsp.h	/^enum weight_types { ATT, EUC_2D, GEO, EXPLICIT, UNHANDLED_WEIGHT_TYPE };$/;"	g
who	src/Makefile	/^who:$/;"	t
wow	src/Makefile	/^wow:$/;"	t
x	include/tsp.h	/^    double x, y;$/;"	m	struct:node_t	typeref:typename:double
x	include/utils.h	/^    int x;$/;"	m	struct:pair_t	typeref:typename:int
xpos	results/utils.py	/^def xpos(i, j, nnodes):$/;"	f
xpos	src/utils.c	/^int xpos(int i, int j, int nnodes) {$/;"	f	typeref:typename:int
xpos_inverse	src/utils.c	/^edge xpos_inverse(int pos, int nnodes) {$/;"	f	typeref:typename:edge
xxpos	results/utils.py	/^def xxpos(i, j, nnodes):$/;"	f
xxpos	src/utils.c	/^int xxpos(int i, int j, int nnodes) {$/;"	f	typeref:typename:int
y	include/tsp.h	/^    double x, y;$/;"	m	struct:node_t	typeref:typename:double
ypos	results/utils.py	/^def ypos(i, j, nnodes):$/;"	f
ypos	src/utils.c	/^int ypos(int i, int j, int nnodes) {$/;"	f	typeref:typename:int
zbest	include/tsp.h	/^    double zbest;$/;"	m	struct:instance_t	typeref:typename:double
zstar	include/tsp.h	/^    double zstar;$/;"	m	struct:solution_t	typeref:typename:double
